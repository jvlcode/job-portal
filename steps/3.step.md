1Ô∏è‚É£2Ô∏è‚É£ Creating Django Models
üõ†Ô∏è Do (Hands-On Code)
User Model (Basic)
Django already provides a built‚Äëin User model (django.contrib.auth.models.User).
For extra fields (like role or phone), we extend it with a Profile model:
# jobs/models.py
from django.db import models
from django.contrib.auth.models import User
class Profile(models.Model):
    ROLE_CHOICES = (
        ('seeker', 'Job Seeker'),
        ('employer', 'Employer'),
    )
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    role = models.CharField(max_length=20, choices=ROLE_CHOICES)
    phone = models.CharField(max_length=15, blank=True, null=True)
def __str__(self):
        return f"{self.user.username} - {self.role}"

Job Model
class Job(models.Model):
    title = models.CharField(max_length=200)
    description = models.TextField()
    company = models.CharField(max_length=100)
    location = models.CharField(max_length=100)
    posted_on = models.DateTimeField(auto_now_add=True)
    created_by = models.ForeignKey(Profile, on_delete=models.CASCADE)
def __str__(self):
        return self.title

Application Model
class Application(models.Model):
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('shortlisted', 'Shortlisted'),
        ('rejected', 'Rejected'),
        ('hired', 'Hired'),
    )
    job = models.ForeignKey(Job, on_delete=models.CASCADE)
    applicant = models.ForeignKey(Profile, on_delete=models.CASCADE)
    resume = models.TextField(blank=True, null=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    applied_on = models.DateTimeField(auto_now_add=True)
def __str__(self):
        return f"{self.applicant.user.username} ‚Üí {self.job.title}"


üßë‚Äçüè´ Explain (Foreign Key Relationship)
    ‚Ä¢ ForeignKey = creates a link between two tables.
    ‚Ä¢ Example: 
        ‚óã In Job, created_by = ForeignKey(Profile) ‚Üí each job is linked to one employer profile.
        ‚óã In Application, 
            ¬ß job = ForeignKey(Job) ‚Üí each application belongs to one job.
            ¬ß applicant = ForeignKey(Profile) ‚Üí each application belongs to one user (seeker).
üîó Relationship Flow
    ‚Ä¢ User ‚Üî Profile ‚Üí One-to-One (each user has one profile).
    ‚Ä¢ Profile ‚Üî Job ‚Üí One-to-Many (one employer can post many jobs).
    ‚Ä¢ Profile ‚Üî Application ‚Üí One-to-Many (one seeker can apply to many jobs).
    ‚Ä¢ Job ‚Üî Application ‚Üí One-to-Many (one job can have many applications).
üëâ This creates a realistic schema: Employers post jobs, seekers apply, and applications track status.

‚úÖ Next step after defining models:
    ‚Ä¢ Run migrations (python manage.py makemigrations && python manage.py migrate).
    ‚Ä¢ Register models in admin.py so learners can test them in Django Admin.

Would you like me to extend this into serializers + API endpoints (so React can fetch jobs and applications), or keep it at the database layer explanation for now?



4Ô∏è‚É£ Make Migrations
python manage.py makemigrations

5Ô∏è‚É£ Apply Migrations
python manage.py migrate

6Ô∏è‚É£ Register Models in jobs/admin.py
from django.contrib import admin
from .models import Profile, Job, Application
admin.site.register(Profile)
admin.site.register(Job)
admin.site.register(Application)


7Ô∏è‚É£ Create Superuser
python manage.py createsuperuser

8Ô∏è‚É£ Run Server & Test
python manage.py runserver
    ‚Ä¢ Open http://127.0.0.1:8000/admin/
    ‚Ä¢ Login with superuser
    ‚Ä¢ You‚Äôll see Profile, Job, Application tables ready to manage.

‚úÖ This order ensures:
    ‚Ä¢ Models are defined ‚Üí migrations applied ‚Üí admin panel ready.
    ‚Ä¢ Students can immediately add jobs, users, and applications in the admin dashboard.

